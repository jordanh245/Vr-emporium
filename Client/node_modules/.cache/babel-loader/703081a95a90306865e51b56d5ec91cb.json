{"ast":null,"code":"import verifyPlainObject from'../utils/verifyPlainObject';export function wrapMapToPropsConstant(getConstant){return function initConstantSelector(dispatch,options){var constant=getConstant(dispatch,options);function constantSelector(){return constant;}constantSelector.dependsOnOwnProps=false;return constantSelector;};}// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\nexport function getDependsOnOwnProps(mapToProps){return mapToProps.dependsOnOwnProps!==null&&mapToProps.dependsOnOwnProps!==undefined?Boolean(mapToProps.dependsOnOwnProps):mapToProps.length!==1;}// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\nexport function wrapMapToPropsFunc(mapToProps,methodName){return function initProxySelector(dispatch,_ref){var displayName=_ref.displayName;var proxy=function mapToPropsProxy(stateOrDispatch,ownProps){return proxy.dependsOnOwnProps?proxy.mapToProps(stateOrDispatch,ownProps):proxy.mapToProps(stateOrDispatch);};// allow detectFactoryAndVerify to get ownProps\nproxy.dependsOnOwnProps=true;proxy.mapToProps=function detectFactoryAndVerify(stateOrDispatch,ownProps){proxy.mapToProps=mapToProps;proxy.dependsOnOwnProps=getDependsOnOwnProps(mapToProps);var props=proxy(stateOrDispatch,ownProps);if(typeof props==='function'){proxy.mapToProps=props;proxy.dependsOnOwnProps=getDependsOnOwnProps(props);props=proxy(stateOrDispatch,ownProps);}if(process.env.NODE_ENV!=='production')verifyPlainObject(props,displayName,methodName);return props;};return proxy;};}","map":{"version":3,"sources":["/Users/jordanharris/Desktop/Vr-emporium/Client/src/node_modules/react-redux/es/connect/wrapMapToProps.js"],"names":["verifyPlainObject","wrapMapToPropsConstant","getConstant","initConstantSelector","dispatch","options","constant","constantSelector","dependsOnOwnProps","getDependsOnOwnProps","mapToProps","undefined","Boolean","length","wrapMapToPropsFunc","methodName","initProxySelector","_ref","displayName","proxy","mapToPropsProxy","stateOrDispatch","ownProps","detectFactoryAndVerify","props","process","env","NODE_ENV"],"mappings":"AAAA,MAAOA,CAAAA,iBAAP,KAA8B,4BAA9B,CACA,MAAO,SAASC,CAAAA,sBAAT,CAAgCC,WAAhC,CAA6C,CAClD,MAAO,SAASC,CAAAA,oBAAT,CAA8BC,QAA9B,CAAwCC,OAAxC,CAAiD,CACtD,GAAIC,CAAAA,QAAQ,CAAGJ,WAAW,CAACE,QAAD,CAAWC,OAAX,CAA1B,CAEA,QAASE,CAAAA,gBAAT,EAA4B,CAC1B,MAAOD,CAAAA,QAAP,CACD,CAEDC,gBAAgB,CAACC,iBAAjB,CAAqC,KAArC,CACA,MAAOD,CAAAA,gBAAP,CACD,CATD,CAUD,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AAEA,MAAO,SAASE,CAAAA,oBAAT,CAA8BC,UAA9B,CAA0C,CAC/C,MAAOA,CAAAA,UAAU,CAACF,iBAAX,GAAiC,IAAjC,EAAyCE,UAAU,CAACF,iBAAX,GAAiCG,SAA1E,CAAsFC,OAAO,CAACF,UAAU,CAACF,iBAAZ,CAA7F,CAA8HE,UAAU,CAACG,MAAX,GAAsB,CAA3J,CACD,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAO,SAASC,CAAAA,kBAAT,CAA4BJ,UAA5B,CAAwCK,UAAxC,CAAoD,CACzD,MAAO,SAASC,CAAAA,iBAAT,CAA2BZ,QAA3B,CAAqCa,IAArC,CAA2C,CAChD,GAAIC,CAAAA,WAAW,CAAGD,IAAI,CAACC,WAAvB,CAEA,GAAIC,CAAAA,KAAK,CAAG,QAASC,CAAAA,eAAT,CAAyBC,eAAzB,CAA0CC,QAA1C,CAAoD,CAC9D,MAAOH,CAAAA,KAAK,CAACX,iBAAN,CAA0BW,KAAK,CAACT,UAAN,CAAiBW,eAAjB,CAAkCC,QAAlC,CAA1B,CAAwEH,KAAK,CAACT,UAAN,CAAiBW,eAAjB,CAA/E,CACD,CAFD,CAEG;AAGHF,KAAK,CAACX,iBAAN,CAA0B,IAA1B,CAEAW,KAAK,CAACT,UAAN,CAAmB,QAASa,CAAAA,sBAAT,CAAgCF,eAAhC,CAAiDC,QAAjD,CAA2D,CAC5EH,KAAK,CAACT,UAAN,CAAmBA,UAAnB,CACAS,KAAK,CAACX,iBAAN,CAA0BC,oBAAoB,CAACC,UAAD,CAA9C,CACA,GAAIc,CAAAA,KAAK,CAAGL,KAAK,CAACE,eAAD,CAAkBC,QAAlB,CAAjB,CAEA,GAAI,MAAOE,CAAAA,KAAP,GAAiB,UAArB,CAAiC,CAC/BL,KAAK,CAACT,UAAN,CAAmBc,KAAnB,CACAL,KAAK,CAACX,iBAAN,CAA0BC,oBAAoB,CAACe,KAAD,CAA9C,CACAA,KAAK,CAAGL,KAAK,CAACE,eAAD,CAAkBC,QAAlB,CAAb,CACD,CAED,GAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C3B,iBAAiB,CAACwB,KAAD,CAAQN,WAAR,CAAqBH,UAArB,CAAjB,CAC3C,MAAOS,CAAAA,KAAP,CACD,CAbD,CAeA,MAAOL,CAAAA,KAAP,CACD,CA1BD,CA2BD","sourcesContent":["import verifyPlainObject from '../utils/verifyPlainObject';\nexport function wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch, options) {\n    var constant = getConstant(dispatch, options);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n\nexport function getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\n\nexport function wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref) {\n    var displayName = _ref.displayName;\n\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (process.env.NODE_ENV !== 'production') verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n\n    return proxy;\n  };\n}"]},"metadata":{},"sourceType":"module"}